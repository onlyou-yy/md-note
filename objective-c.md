## objective-c 基本概念

objective-c 简称 oc ，是在C的基础上新增了1小部分面向对戏那个的语法，将C的复杂、繁琐的语法封装的更为简单，而且OC是完全兼容 C
+ `#import` 指令：同1个文件无论#import多少次. 最终都只会包含1次 不会出现重复包含的情况.
+ NSLog函数：自动换行，会输出一些其他的调试信息.

## 数据类型
oc 中的数据类型有是完全兼容 c 中的类型的，在oc 中也有很多自己的数据类型
+ BOOL : YES ｜ NO
+ Boolean : true | false
+ class : 类
+ id : 万能指针
+ nil : 空指针
+ SEL : 选择器
+ block : 块

## 类和对象

### 定义类

类的声明
```objc
@interface 类名 : NSObject
{
  //属性默认是私有的
  //使用@public 之后的变量都是public的
  类型 属性;
}
- (方法返回值类型)方法名;
- (方法返回值类型)方法名:(参数类型)参数名1 :(参数类型)参数名2;
- (方法返回值类型)方法名:(参数类型)参数名1 and:(参数类型)参数名2;
@end
```
类的实现
```objc
@implementation 类名
- (方法返回值类型)方法名{
  //todo...
}
- (方法返回值类型)方法名:(参数类型)参数名1 :(参数类型)参数名2{
  //todo...
}
- (方法返回值类型)方法名:(参数类型)参数名1 and:(参数类型)参数名2{
  //todo...
}
@end
```
使用
```objc
#import <Foundation/Foundation.h>

@interface Person : NSObject
{
  //属性默认是私有的
  //使用@public 之后的变量都是public的
  @public
  NSString *_name;
  int _age;
  float _height;
  BOOL _sex;
}
- (void)say;
- (void)saySomething:(NSString *)something;
- (void)eatSomething:(int)count :(NSString *)something;
- (void)eatWith:(NSString *)food1 and:(NSString *)food2;
@end

@implementation Person
- (void)say
{
  // 在方法中可以直接访问 属性
  // 谁调用了这个方法，那么访问到的变量就是谁的
  // 可以通过 self->_name 访问也可以通过 _name 直接访问
  NSLog(@"Person say 'my name is %@'",_name);
}
/*
方法名叫 saySomething:
参数 (NSString *)something
*/
- (void)saySomething:(NSString *)something
{
  NSLog(@"Person say %@",something);
}
/*
方法名叫 eatSomething: :
参数 (int)count (NSString *)something
*/
- (void)eatSomething:(int)count :(NSString *)something
{
  NSLog(@"Person eat %d %@",count,something);
}
/*
方法名叫 eatWith: and:
参数 (NSString *)food1 and:(NSString *)food2
*/
- (void)eatWith:(NSString *)food1 and:(NSString *)food2
{
  NSLog(@"Person eat %@ and %@",food1,food2);
}
@end


int main(int args,char *argv[]){
  //实例化就是调用 new方法的过程
  Person *p = [Person new];
  p->_name = @"jack";
  p->_age = 1;
  (*p)._height = 180.f;

  NSLog(@"Person _name:%@",p->_name);
  NSLog(@"Person _age:%d",p->_age);
  NSLog(@"Person _age:%f",p->_height);

  [p say];
  [p saySomething:@"爱你"];
  [p eatSomething:3 :@"fish"];
  [p eatWith:@"coffe" and:@"fish"];

  return 0;
}
```
**总结**
+ 访问属性 可以使用 `对象->属性名` 或者 指针的`.`进行访问` (*对象).属性名`
+ 访问属性需要用 `[对象 方法名:参数1 :参数2]`

+ 对于属性的名方法和规范
  + `类型 _变量名`;

+ 对于方法的命名方法和规范
  + `- (返回类型)方法名:(参数类型)参数名 :(参数类型)参数名`
  + 方法名的命名规范：`动作With:(参数类型)参数名 and:(参数类型)参数名`
+ 在类中可以使用 `self`来访问自己的方法，`self`是一个指针，指向类的实例对象

## 对象在内存中的存储

### 内存中的五大区域
+ 栈：存储局部变量.
+ 堆：程序员手动申请的字节空间 malloc calloc realloc函数.
+ BSS段：存储未被初始化的全局变量 静态变量.
+ 数据段(常量区)：存储已被初始化的全局 静态变量 常量数据.
+ 代码段：存储代码. 存储程序的代码.

### 类加载
+ 在创建对象的时候 肯定是需要访问类的
+ 在创建对象的时候 肯定是需要访问类的

在程序运行期间 当某个类第1次被访问到的时候. 会将这个类存储到内存中的代码段区域.这个过程叫做类加载.只有类在第1次被访问的时候,才会做类加载. 一旦类被加载到代码段以后. 直到程序结束的时候才会被释放.

### 对象在内存中究竟是如何存储的
```objc
Person *p1 = [Person new];
```
+ Person *p1; 会在栈内存中申请1块空间. 在栈内存中声明1个Person类型的指针变量p1。p1是1个指针变量.  那么只能存储地址.
+ `[Person new]` 真正在内存中创建对象的其实是这句代码.

**new做的事情**
+ 在堆内存中申请1块合适大小的空间.
+ 在这个空间中根据类的模板创建对象 
  + 类模板中定义了什么属性.就把这些属性依次的声明在对象之中.对象中还有另外1个属性 叫做isa 是1个指针. 指向对象所属的类在代码段中的地址
+ 初始化对象的属性
  + 如果属性的类型是基本数据类型 那么就赋值为0
  + 如果属性的类型是C语言的指针类型 那么就赋值为NULL
  + 如果属性的类型是OC的类指针类型9 那么就赋值为nil
+ 返回对象的地址

### 为什么不把方法存储在对象之中?
因为每1个对象的方法的代码实现都是一模一样的  没有必要为每1个对象都保存1个方法 这样的话就太浪费空间了.既然都一样 那么就只保持1份.

### nil与NULL
+ NULL：只能作为指针变量的值. 如果1个指针变量的值是NULL值代表. 代表这个指针不指向内存中的任何1块空间，NULL其实等价于0  NULL其实是1个宏. 就是0
+ nil：只能作为指针变量的值. 代表这个指针变量不指向内存中的任何空间. nil其实也等价于0 也是1个宏. 就是0. 所以, NULL和nil其实是一样的 。
+ 使用建议：虽然使用NULL的地方可以是nil 使用 nil的地方可以使用NULL 但是不建议大家去随便使用.

**C指针用NULL**
```objc
int *p1 = NULL; //p1指针不指向内存中的任何1块空间.
```
**OC的类指针用nil**
```objc
Person *p1 = nil; p1指针不指向任何对象.
```

**注意**

+ 对象中只有属性,而没有方法. 自己类的属性外加1个isa指针指向代码段中的类.
+ 如何访问对象的属性，
  + 指针名->属性名; 根据指针 找到指针指向的对象 再找到对象中的属性来访问
+ 如何调用方法
  + `[指针名 方法名];`先根据指针名找到对象,对象发现要调用方法 再根据对象的isa指针找到类.然后调用类里的方法.



## 分组导航标记

分组导航标记:

+ `#pragma mark 分组名`
	​       就会在导航条对应的位置显示1个标题.
+  `#pragma mark -`
	       就会在导航条对应的位置显示1条水平分隔线.
+  `#pragma mark - 分组名`
	       就会在导航条对应的位置先产生1条水平分割线.再显示标题.



## 方法与函数

我们之前在C中学习的函数,就叫做函数，在OC类中写的方法.就叫做方法

### 相同点

都是用来封装1段代码的. 将1段代码封装在其中, 表示1个相对独立的功能， 函数或者方法只要被调用.那么封装在其中的代码就会被自动执行.

### 不同点

+ 语法不同.
+ 定义的位置不一样，OC方法的声明只能写在@interface的大括号的外面,实现只能写在@implementation之中，函数除了在函数的内部和@interface的大括号之中 其他的地方都是可以写，就算把函数写在类中 这个函数仍然不属于类 所以创建的对象中也没有这个函数，注意; 函数不要写到类中.虽然这样是可以的 但是你千万不要这么做 因为这么做是极度的不规范的.
+ 调用的方式也不一样，函数可以直接调用，但是 方法必须要先创建对象 通过对象来调用.
+ 方法数是属于类的

### 注意点

+ `@interface`是类的声明. `@implementation`是类的实现 他们之间不能相互嵌套
+ 类必须要先声明然后再实现
+ 类的声明和实现必须都要有 就算没有方法 类的实现也不必不可少的
+ 类的声明必须要放在使用类的前面  实现可以放在使用类的后面
+ 声明类的时候 类的声明和实现必须要同时存在，特殊情况下可以只有实现 没有声明（虽然可以这样,但是我们平时在写类的时候千万不要这么写 因为这么写是极度不规范的）
+ 属性名一定要以下划线开头 这是规范. 否则后面的知识点你就对不上号， 类名 每1个单词的首字母大写
+ 属性不允许声明的时候初始化 在为类写1个属性的时候 不允许在声明属性的时候为属性赋值.
+ OC方法必须要创建对象通过对象名来调用
+ 方法只有声明 没有实现
	+ 如果方法只有声明 没有实现  编译器会给1个警告  不会报错.
	+ 如果指针指向的对象 有方法的声明 而没有方法的实现 那么这个时候通过指针来调用这个方法，在运行的时候  就会报错（`unrecognized selector sent to instance 0x100420510` 只要你看到了这个错误.说明要么对象中根本就没有这个方法. 要么只有方法的声明而没有方法的实现）



## 多文件开发

把1个类写在1个模块之中. 而1个模块至少包含两个文件.

` .h 头文件`

写的类声明 因为要用到Foundation框架中的类 NSObject 所以在这个头文件中要引入Foundation框架的头文件 然后将类的声明的部分写在.h文件中

` .m 实现文件`

先引入模块的头文件 这样才会有类的声明,再写上类的实现。如果要用到类. **只需要引入这个了模块的头文件就可以直接使用了**

> **添加类模块的更简洁的方式**
>
>  `NewFile->Cocoa Class` 自动生成模块文件  .h  .m 。自动的将类的声明和实现写好



### 枚举或者结构体定义在什么地方

如果只是1个类要用。那么就定义在这个类的头文件中。 如果多个类要用，那么就定义在单的头文中，谁要用谁就去引用。



## 异常处理

### 什么是异常

程序可以编译 链接 执行，当程序在执行的时候 处于某种特定条件下 程序的执行就会终止.

**异常的后果**: 程序会立即崩溃.程序立即终止运行.并且后面的代码不会执行了

### 如何处理异常

为了让程序在执行的时候如果发生了异常而不崩溃 而是继续往下执行

```objc
@try
{
	//可能出错的代码
}
@catch(NSException *ex)
{
	//当出现错误时执行,之后程序不回崩溃，会继续往下执行
}
@finally
{
  //无论是否出错都会执行
}
```



## 类方法

**在1个Target中无法访问另外1个Target中的类**

### OC中的方法分为两种

#### **对象方法/实例方法**

如果想要调用对象方法就必须要先创建对象 通过对象名来调用.

**类方法**

类方法的调用不依赖于对象.如果要调用类方法 不需要去创建对象.而是直接通过类名来调用

### 声明

对象方法的声明

```objc
// - (返回值类型)方法名
- (void)sayHi;
```

类方法的声明

```objc
// + (返回值类型)方法名;
+ (void)sayHi;
```

### 调用

+ 对象方法: 先创建对象 再通过对象名来调用.
+ 类方法: 不需要通过对象名来调用 所以如果要调用类方法不需要创建对象,而是直接使用类名来调用`[类名 类方法名];`

### 类方法的特点

 1). 节约空间: 因为调用类方法不需要创建对象. 这样就节约了空间.

 2). 提高效率: 因为调用类方法不需要拐弯 直接找到类 直接执行类中的类方法.

**在类方法中不能直接访问属性**

+ 属性是在对象创建的时候.跟随着对象一起创建在对象之中.

+ 类第1次被访问的时候,会做类加载. 是把类的代码存储在代码段

因为属性只有在对象创建的时候才会创建在对象之中，而类方法在执行的时候.有可能还没有对象. 对象都没有 你访问个毛的属性，虽然不能直接访问属性. 但是我们可以在类方法中创建1个对象 访问这个对象的属性.

> 什么时候我们可以将方法定义为类方法呢?
>
> 如果方法**不需要直接访问属性 也不需要直接调用其他的对象方法**，那么我们就可以将这个方法定义为类方法，这样就 节约空间 提高效率.

### 关于类方法的规范

如果我们写1个类,那么就要求为**这个类提供1个和类名同名的类方法**

```objc
@interface Person : NSObject
{
  NSString *_name;
}
// + (Person *)person;
+ (instancetype)person;
@end
@implementation Person : NSObject
{
  NSString *_name;
}
+ (instancetype)person{
  Person *p = [Person new];
  return p;
}
@end
```

**如果方法的返回值是当前类的对象,那么方法的返回值就写*instancetype***

***如果你希望创建爱的对象的属性的值由调用者指定 那么就为这个类方法带参数***：`类名WithXXX: ......`



## 属性的封装

### **封装**

类就是更高级别的封装.类将数据和行为封装为了1个整体.

+ 屏蔽内部的实现.外界不需要知道内部是如何实现的 只需要知道这个对象有什么用.
+ 方便操作
+ 后期的维护十分的便利

### 如何实现封装

+ 将属性的@public去掉.因为一旦写上@public就意味着外界可以直接访问对象的这个属性.
+ 为类提供1个方法,这个方法专门为这个属性赋值.这个方法我们叫做**setter**
+ 为类提供1个方法,这个方法专门获取属性值.这个方法我们叫做**getter**

```objc
@interface Student : NSObject
{
    NSString *_name;
    int _age;
}
-(void)setName:(NSString*)name;
-(NSString*)name;
-(void)setAge:(int)age;
-(int)age;
```



## Xcode文档

苹果提供了很多很多的框架.框架中有很多类 很多的函数 提供了一些数据类型，可以在xcode 的`help->developer Documentation`中查看文档说明

![image-20221119104225156](/Users/gcb/Desktop/ljf_new/file/md-note/objective-c/image-20221119104225156.png)



## static关键字

+ static不能修饰属性 也不能修饰方法.
+ static可以修饰方法中的局部变量。如果方法中的局部变量被static修饰,那么这个变量就会被变成静态变量，存储在常量区 当方法执行完毕之后 不会回收 下次再执行这个方法的时候 直接使用 而不会再声明了

## self关键字

**self用在对象方法中**指向当前对象，**slef用在类方法中**（在类方法中 self也是1个指针.执行当前这个类在代码段中的地址）指向当前这个类

> **取到类在代码段中的地址的方式**
>
> + 调试查看对象的isa指针的值.
> + 在类方法中查看self的值
> + 调用对象的对象方法class 就会返回这个对象所属的类在代码段中的地址
> + 调用类的类方法class 就会返回这个类在代码段中的地址.

## 继承

儿子类想拥有父亲类中的所有的成员.但是不想自己去定义,而是想凭空拥有.

```objc
@interface 类名 : 父亲类的名称

@end
```

子类一旦从父类继承 就意味着子类拥有了父类的所有的成员 而不用自己去定义，如果有1个成员不是所有的子类都拥有的.那么这个成员就不应该定义在父类之中

**什么时候应该使用继承?**

如果发现另外1个类中的成员我也想有 那么这个时候就可以使用继承，千万不要为了继承而去继承. 不要为了仅仅是得到某个类的成员你就不顾伦理去乱继承.

凡是满足is a关系的类 就可以拥有继承的关系，比如`Student is a Person`

### 继承的特点

1. 单根性，**1个类只能有1个父类** 不能有多个父类.
1. 传递性，A类从B类继承,B类从C类继承. 那么A类就同时拥有B、C类的成员.
1. NSObject类是Foundation框架中的类.在这个类中有1个类方法new**这个方法是用来创建对象的.**方法的返回值是创建的这个对象的指针，也就是说,如果要创建类的对象,就必须要调用这个new方法

### 关于子类和父类同名属性

1. **子类中不能存在和父类同名的属性**.

     因为子类从父类继承,就意味着子类拥有了父类的所有的成员 包括属性和方法.

     也就相当于子类中其实已经定义了.

     如果子类再定义1个同名的属性 很明显就冲突了.

  2. **super关键字.**
     1). 可以用在类方法和对象方法之中.

     2). 在对象方法中可以使用super关键字调用当前对象从父类继承过来的对象方法.

     3). 在类方法中 super关键字可以调用当前类从父类继承过来的类方法.

        a. 类方法也能被子类继承. 父类中的类方法可以使用父类名来调用 也可以使用子类名调用.

     ​	b. 在子类的类方法中 可以使用super关键字调用父类的类方法.

     4). super只能用来调用父类的对象方法或者类方法  不能用来访问属性.

  3. **子类从父类继承.**
     1). 相当于子类模板中拥有了父类模板中的所有的成员.

     2). 创建1个子类对象,仍然是根据子类模板来创建对象.

     ​	只不过子类模板中拥有父类模板中的成员.

     ​	所以,子类对象中既有子类的成员也有父类的成员.

     3). super特指这个方法是从父类继承过来的.

     ​	 super是指当前类或者对象的这个方法是从父类继承过来的.

### 访问修饰符

+ `@private`: 私有 被`@private`修饰的属性只能在本类的内部访问.只能在本类的方法实现中访问
+ `@protected`: 受保护的. 被`@protected`修饰的属性只能在本类和本类的子类中访问
+ `@package`: 被`@package`修饰的属性 可以在当前框架中访问
+ `@public`: 公共的.被`@public`修饰的属性 可以在任意的地方访问

如果不为属性指定访问修饰符 那么默认的就是`@protected`，**访问修饰符只能用来修饰属性 不能用来修饰方法**

**子类仍然可以继承父类的私有属性**

只不过,在子类中无法去直接访问从父类继承过来的私有属性，但是如果父类中有1个方法再为属性赋值或者取值，那么子类可以调用这个方法间接的访问父类的私有属性.

### 私有方法

方法不写声明,只写实现. 那么这个方法就是1个私有方法，只能在本类的其他方法中调用 不能再外界调用.

### **里氏替换原则--- LSP**

**当1个父类指针指向1个子类对象的时候,这里就有里氏替换原则.**

子类可以替换父类的位置.并且程序的功能不受影响，因为父类中拥有的成员 子类都有. 所以不会影响程序的功能

比如`Student`继承了`Person`

```objc
Person *p = [Student new];
```

访问特点：

+ 只能访问`Person`类中有定义的方法和属性，而`Student`类中定义的独有的属性和方法无法访问（也就是说**只能访问具有共性的东西**）
+ 如果`Student`类中重写`Person`类的方法，那么访问的就是重新之后的方法

### 方法重写

子类继承了父类的方法,就意味着子类拥有了这个功能，有的时候: 虽然子类也拥有父类的这个行为. 但是这个行为的具体的实现和父类不同（多态）

如何重写：***直接在类的实现中将这个方法重新实现一遍就可以了***

### description

```objc
Student *stu = [Student new];
// %p 打印的是指针变量的值
NSLog("%p",stu);
// %@ 打印的是指针指向的对象.
NSLog("%@",stu);
```

`NSLog("%@",p);`原理：

+ 调用传入的对象的 description方法.
+ 拿到这个方法的返回值 这个返回值是1个字符串
+ 将这个字符串输出.

description方法是定义在NSObject类之中的，所以我们可以通过重写来自定义输出

```objc
@implementation Student
- (NSString *)description{
  return [NSString stringWithFormat:@"name %@",_name];
}
@end
```





































https://blog.csdn.net/panjiye82?type=blog&year=2022&month=05

https://www.bilibili.com/video/BV1NJ411T78u?p=10&spm_id_from=pageDriver&vd_source=41ed998ac767425fb616fd9071ce9682