## 库推荐

+ HarmonyOS工具库 [harmony-utils](https://ohpm.openharmony.cn/#/cn/detail/@pura%2Fharmony-utils)
+ 简单易用的媒资预览框架 [media-preview](https://ohpm.openharmony.cn/#/cn/detail/@lyb%2Fmedia-preview)
+ 网络请求库 [axios](https://ohpm.openharmony.cn/#/cn/detail/@ohos%2Faxios)
+ UI组件库 [ibest-ui](https://ohpm.openharmony.cn/#/cn/detail/@ibestservices%2Fibest-ui)，有严格UI限制的不建议使用
+ 状态管理库[`StateStore`](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-global-state-management-state-store)

## Artts

Artts其实就是TypeScript的一个超集，但是又移除了一些方法和特性，比如不支持delete，for .. in，不支持 any （any类型可以用 ESObject 代替）等。[从TypeScript到ArkTS的适配规则](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/typescript-to-arkts-migration-guide)

## ForEach 的key问题

在使用`ForEach`进行循环渲染的时候要注意 key 默认情况下key是通过函数`(item: Object, index: number) => { return index + '__' + JSON.stringify(item); }`生成的， 如果相同的key就只会渲染一遍，比如`['one','two','two','three']`在 keyGenerator 函数为`item => item`是就只会渲染`one','two','three'`。需要制定不同的key，获取不写 keyGenerator 函数才会全部渲染

```tsx
@State simpleList: Array<string> = ['one', 'two', 'two', 'three'];

ForEach(this.simpleList, (item: string) => {
  ChildItem({ item: item })
},(_,idx:number) => idx);

```

## canvas尺寸坑导出类型

`imageInfo.size`返回的图片的尺寸信息单位是`px`，在Canvas中单位使用的都是`vp`，要做统一单位将`px`转`vp`（`px2vp`），不然在操作`canvas`时会导致尺寸对应不上的问题。

```ts
const imageSource = image.createImageSource(fileHandle.fd);
const imageInfo = imageSource.getImageInfoSync();
// imageInfo.size 的尺寸单位是 px

// 单位 vp
const offCanvas = new OffscreenCanvas(width, height); 
const offContext = offCanvas.getContext("2d", new RenderingContextSettings(true));
// 单位 vp
offContext.drawImage(pixelMap, 0, 0, canvasWidth, canvasHeight); 

// 保存时要指定图片类型，保存原来图片的类型，否则保存出来的图片大小可能会和原图尺寸差很多
const path = await ImageUtil.savePixelMap(pixelMap, tempDir, filename, imageInfo.mimeType);
```



## Row/Column/Grid 高度错误的问题

在使用`Grid`和`Row/Column`多层嵌套并且没有设置高度的时候可能会导致高度占满容器高度，比如

```tsx
Column() {
  Column() {
    Column() {
      Row() {
        Text("title")
      }

      Grid() {
        GridItem() {
          Column() {
            Text("test1")
          }
        }

        GridItem() {
          Column() {
            Text("test2")
          }
        }
      }.columnsTemplate('1fr 1fr')
    }
  }

  Text("footer")
}
```

`grid`的高度就会显示异常，可以通过设置高度的方式解决，也可以通过在外层用`Scroll/List`进行包裹来解决，还可以用`GridRow/GridCol`代替`Grid/GridItem`解决

```tsx
Column() {
  Scroll() {
    Column() {
      Row() {
        Text("title")
      }

      Grid() {
        GridItem() {
          Column() {
            Text("test1")
          }
        }

        GridItem() {
          Column() {
            Text("test2")
          }
        }
      }.columnsTemplate('1fr 1fr')
    }
  }

  Text("footer")
}
```

```tsx
Column() {
  Column() {
    Column() {
      Row() {
        Text("title")
      }
      GridRow({
        columns: {xs: 2, sm: 2, md: 2, lg: 2, xl: 2, xxl: 2
        },
      }) {
        GridCol() {
          Text("GridCol1")
        }

        GridCol() {
          Text("GridCol2")
        }
      }
    }
  }

  Text("footer")
}
```



## 状态管理

### V1

鸿蒙的状态管理类似于`Vue`，同样是使用`Proxy`对数据进行劫持，以及对依赖此数据组件进行依赖搜集，当绑定的数据更新时更新组件。但是需要注意在`状态管理V1`的时候使用`@State`修饰的数据，如果是对象就只能对第一层的数据进行监听，深层次的数据更新并不会触发组件更新，如果需要深层次的数据也触发组件更新的话就需要为这个数据创建一个类并使用`@Observed`装饰，并且**这个类同样只有第一层数据的数据变化的时候才会触发组件更新，深层的数据还是需要使用`@Observed`装饰，并且需要注意深层的这个数据必须要传递给子组件，子组件通过`@ObjectLink`接收使用才会响应更新**

```tsx
@Observed
class Data2 {
  count: number = 0;
}

interface Data1 {
  count: number;
  child: Data2
}

@Component
struct Children {
  @ObjectLink data: Data2

  build() {
    Text("Children data2.count:" + this.data.count).onClick(() => {
      this.data.count += 1;// 会更新但是父组件不会更新
    })
  }
}

@Component
export struct TestExample {
  @State data: Data1 = {
    count: 0,
    child: new Data2
  };

  build() {
    NavDestination() {
      Column({ space: 10 }) {
        Text("data1.count:" + this.data.count).onClick(() => {
          this.data.count += 1;//会更新
        })
        Text("data1.child.count:" + this.data.child.count).onClick(() => {
          this.data.child.count += 1;//不会更新，Children会更新
        })

        Children({
          data: this.data.child
        })
      }
    }.title("StateV1")
  }
}
```

可以发现在使用`@Observed/@ObjectLink`时如果要做响应式的深层数据的话，要么就需要使用为每一个子对象数据创建一个类和组件，要么就需要将这些深层的数据提取出来扁平化处理用多个`@State`装饰的变量处理，或者将子对象数据扁平化之后塞到一个对象中形成新的对象（但是这样处理后也就不需要使用`@Observed/@ObjectLink`了）。

**@Prop装饰变量时会进行深拷贝，在拷贝的过程中除了基本类型、Map、Set、Date、Array外，都会丢失类型**

### V2

**@Local的观测能力仅限于被装饰的变量本身。当装饰简单类型时，能够观测到对变量的赋值；当装饰对象类型时，仅能观测到对对象整体的赋值；当装饰数组类型时，能观测到数组整体以及数组元素项的变化；当装饰Array、Set、Map、Date等内嵌类型时，可以观测到通过API调用带来的变化**

也就说对于对象来说只能通过重新赋值整个对象才能触发更新。和React的redux思想相似，在React中更新Store中对象中某个属性的数据状态的时候可以使用对象扩展来快速浅拷贝，但是在artts中时不支持对象扩展运算的，这就变得非常麻烦。要实现对象的响应式更新就需要使用`@ObservedV2/@Trace`来定义对象中的哪个属性时需要成为响应式数据，如果需要成为响应式数据的属性很多那就更麻烦了。

### V1和V2融合使用

我们其实可以将`V1`版本对对象的浅层数据都转化响应式数据的特性和`V2`的`@ObservedV2/@Trace`可以自定义响应式数据而不用在子组件中使用的特性结合起来就可以得到一个类似`Vue`的状态管理系统。

需要注意`V2`的`@ObservedV2`装饰的类不能直接使用在`V1`的装饰器中，但是可以使用在对象的内部

```tsx
@ObservedV2
class Data{
	@Trace
  name:string = "";
}
@State data:DataV2 = new Data();// 这样是不行的

interface WrapData = {
  data:Data
}
@State data:WrapData = {
  data:new Data
};// 这样是可以的
```

在项目中我们可以创建一个专门将普通数据转化成响应式数据的类

```ts
@ObservedV2
class Ref<T>{
	@Trace
  value:T;
  constructor(val:T){
    this.value = val;
  }
}
```

其实这个就和`Vue3`中对普通类型数据使用`ref`处理是一样的思想，在使用的时候需要保持数据的引用不变

```tsx
@ObservedV2
class Ref<T> {
  @Trace
  value: T;

  constructor(val: T) {
    this.value = val;
  }
}

interface Data {
  count: number
  child: Child
}

interface Child {
  count: number
  count2: Ref<number>;
}

@Component
export struct TestExample {
  @State data: Data = {
    count: 0,
    child: {
      count: 0,
      count2: new Ref<number>(0)
    }
  };

  build() {
    NavDestination() {
      Text("data.count:" + this.data.count).onClick(() => {
        this.data.count += 1;// 会更新
      })
      Text("data.child.count:" + this.data.child.count).onClick(() => {
        this.data.child.count += 1;// 不会更新
      })
      Text("data.child.count2:" + this.data.child.count2.value).onClick(() => {
        this.data.child.count2.value += 1;// 会更新
      })
    }.title("xxxx")

  }
}
```

在使用`Ref`的时候还有几个问题需要特别注意：

1. 在使用`JSON.stringify`的时候会使`Ref`转换成普通对象数据并且丢失响应式特性。
2. `@Prop`接收的数据是进行深拷贝过的，即使对象能正常使用但是在子组件修改数据的也是不会响应同步到父组件
3. `@Link`是**无法接收非`V1`状态装饰器装饰的数据**的（比如只能是上面data，data中的数据也是不行的），也就无法使用这个特性实现双向数据同步

所以在开发的时候，在使用 `Ref`时尽量不要用`JSON.stringify`进行操作（比如复制）要确保 `Ref` 对象不变，仅修改`Ref.value`。尽量使用接口类的方式进行状态的管理，比如我们要接收用户的信息之后，需要对用户的名称`name`，存款`amount`修改，那么我们可以先创建一个接口`IUserInfo`，然后再实现这个接口`UserInfo`

```tsx
interface IUserInfo {
  name: string;
  age: number;
  deposit: IDeposit
}

interface IDeposit {
  amount: number;
  unit: string;
  bank: string;
}

class UserInfo implements IUserInfo {
  private _name: Ref<string> = new Ref("");
  age: number = 0;
  deposit: Deposit = new Deposit();

  constructor(data?: IUserInfo) {
    if (data) {
      ObjectUtil.assign(this, data);
      this.deposit = new Deposit(data.deposit);
    }
  }

  get name() {
    return this._name.value;
  }

  set name(val: string) {
    this._name.value = val;
  }

  valueOf(): IUserInfo {
    return {
      name: this.name,
      age: this.age,
      deposit: this.deposit.valueOf(),
    };
  }
}

class Deposit implements IDeposit {
  private _amount: Ref<number> = new Ref(0);
  private _bank: Ref<string> = new Ref("");
  unit: string = "CNY";

  constructor(data?: IDeposit) {
    if (data) {
      ObjectUtil.assign(this, data);
    }
  }

  get amount() {
    return this._amount.value;
  }

  set amount(val: number) {
    this._amount.value = val;
  }

  get bank() {
    return this._bank.value;
  }

  set bank(val: string) {
    this._bank.value = val;
  }

  valueOf(): IDeposit {
    return {
      unit: this.unit,
      amount: this.amount,
      bank: this.bank,
    };
  }
}
```

这样包装过后就不用担心`Ref`被不确定的修改，同时使用`valueOf` 方法就可以提取出纯数据对象之后使用`JSON.Stringify`对纯数据对象操作也就可以了。那么在组件中这些数据的使用效果

```tsx
const getUserInfo: () => Promise<IUserInfo> = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const userInfo: IUserInfo = {
        name: 'jack',
        age: 18,
        deposit: {
          amount: 10000,
          unit: "CNY",
          bank: "CCIT"
        }
      }
      resolve(userInfo);
    }, 300)
  })
}

@Component
export struct DepositInfo {
  @Prop deposit: Deposit;

  build() {
    Column({ space: 10 }) {
      Text(`deposit amount: ${this.deposit.unit} ${this.deposit.amount}`);
      Text(`deposit bank: ${this.deposit.bank}`);
      Text("change bank").backgroundColor("red").onClick(() => {
        this.deposit.bank += 1; // 会更新，但父组件不会更新
      })
      Text("change amount").backgroundColor("red").onClick(() => {
        this.deposit.amount += 1; // 会更新，但父组件不会更新
      })
    }.backgroundColor(Color.Blue);
  }
}

@Component
export struct TestExample {
  @State userInfo: UserInfo = new UserInfo();

  async aboutToAppear() {
    const userData = await getUserInfo();
    this.userInfo = new UserInfo(userData);
  }

  build() {
    NavDestination() {
      Column({ space: 10 }) {
        Text("user name:" + this.userInfo.name)
        Text("user deposit bank:" + this.userInfo.deposit.bank)
        Text("change name").backgroundColor("red").onClick(() => {
          this.userInfo.name += "1"; // 会更新
        })
        Text("change deposit bank").backgroundColor("red").onClick(() => {
          this.userInfo.deposit.bank += "1"; // 会更新，但子组件不会更新
        })
        Text("change deposit").backgroundColor("red").onClick(() => {
          this.userInfo.deposit.amount += 1; // 不会更新
        })

        Divider()

        DepositInfo({
          deposit: this.userInfo.deposit
        })
      }
    }.title("xxxx")
  }
}
```

会发现在父组件中，即使是深层的数据修改也会更新页面，但是在父组件中更新深层的数据对象并不能触发依赖这个数据的子组件更新，这是因为`@Prop`会进行深拷贝，将原来数据和组件的依赖关系清除。那么如果要使得深层的数据更新子组件也更新（`@Link`的效果）应该怎么修改？答案是不使用`@Prop`直接传数据（但是要确保初始化时就绑定同一对象，因为不使用`@Prop`在对象更新时并不能触发子组件更新去同步对象数据）

```tsx
class SourceSync {
  setData(data?: ESObject, keyHandle?: (key: string, value: ESObject) => boolean) {
    this.syncData(data, keyHandle);
  }

  syncData(data?: ESObject, keyHandle?: (key: string, value: ESObject) => boolean) {
    if (data) {
      const target = this as Record<string, ESObject>;
      const source = data as Record<string, ESObject>;
      const keys = Object.keys(source);
      for (let key of keys) {
        if (keyHandle && keyHandle(key, source[key])) {
          continue;
        }
        target[key] = source[key];
      }
    }
  }

  valueOf(): Record<string, ESObject> {
    const target = this as Record<string, ESObject>;
    const objKeys = Object.keys(target);
    const record: Record<string, ESObject> = {};
    for (let key of objKeys) {
      if (key === "propChangeListeners") {
        continue;
      }
      if (key.startsWith("_")) {
        const tempKey = key.slice(1);
        record[tempKey] = target[tempKey];
        continue;
      }
      if (target[key] instanceof SourceSync) {
        record[key] = target[key].valueOf()
        continue;
      }
      record[key] = target[key];
    }
    return record;
  }

  private propChangeListeners: Array<(key: string, value: ESObject) => void> = [];

  onPropChange(fn: (key?: string, value?: ESObject) => void) {
    this.propChangeListeners.push(fn);
  }

  offPropChange(fn: (key?: string, value?: ESObject) => void) {
    this.propChangeListeners = this.propChangeListeners.filter(ev => ev !== fn)
  }

  emitPropListeners(key: string, value: ESObject) {
    this.propChangeListeners.forEach(fn => {
      fn(key, value);
    })
  }
}

class UserInfo extends SourceSync implements IUserInfo {
  private _name: Ref<string> = new Ref("");
  age: number = 0;
  deposit: Deposit = new Deposit();

  constructor(data?: IUserInfo) {
    super();
    this.setData(data);
  }

  setData(data?: ESObject): void {
    this.syncData(data, (key, value: ESObject) => {
      if (key === "deposit") {
        this.deposit.setData(value);
        return true;
      }
      return false;
    })
  }

  get name() {
    return this._name.value;
  }

  set name(val: string) {
    this._name.value = val;
  }
}

class Deposit extends SourceSync implements IDeposit {
  private _amount: Ref<number> = new Ref(0);
  private _bank: Ref<string> = new Ref("");
  unit: string = "CNY";

  constructor(data?: IDeposit) {
    super();
    this.setData(data);
  }

  get amount() {
    return this._amount.value;
  }

  set amount(val: number) {
    this._amount.value = val;
  }

  get bank() {
    return this._bank.value;
  }

  set bank(val: string) {
    this._bank.value = val;
  }
}
```

```tsx
@Component
export struct DepositInfo {
  deposit?: Deposit;
  build() {
    Column({ space: 10 }) {
      Text(`deposit amount: ${this.deposit?.unit} ${this.deposit?.amount}`);
      Text(`deposit bank: ${this.deposit?.bank}`);
      Text("change bank").backgroundColor("red").onClick(() => {
        this.deposit && (this.deposit.bank += 1); // 会更新，父组件也会更新
      })
      Text("change amount").backgroundColor("red").onClick(() => {
        this.deposit && (this.deposit.amount += 1); // 会更新，父组件也会更新
      })
    }.backgroundColor(Color.Blue);
  }
}

@Component
export struct TestExample {
  @State userInfo: UserInfo = new UserInfo();
  async aboutToAppear() {
    const userData = await getUserInfo();
    // this.userInfo = new UserInfo(userData);
    this.userInfo.setData(userData);
  }
}
```

### 设计状态管理中心

**`Ref`主要解决的还是深层数据不响应更新的问题**，在组件间传递的时候使用了`@Prop`就会导致响应性丢失。因此`Ref`更适合用来做**状态管理中心**（类似vuex，因为数据来源统一且不容易因为复制导致对象引用修改导致响应性丢失）。

> 可以使用官方推荐的的[`StateStore`](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-global-state-management-state-store)状态管理库

```tsx

```



## 自定义弹窗的数据传递

```ts
import { BusinessError } from '@kit.BasicServicesKit';
import { ComponentContent, promptAction } from '@kit.ArkUI';
import { UIContext } from '@ohos.arkui.UIContext';
import { AppUtil, ObjectUtil } from '@pura/harmony-utils';
import { Log } from './log';

export interface ICustomDialogData<T = ESObject> {
  wrappedBuilder: WrappedBuilder<ESObject>;
  builderParams?: T;
  options?: promptAction.BaseDialogOptions;
}

interface IHandleFunction {
  isOnce: boolean;
  handle: Function;
}

export class CustomDialogHandle {
  ctx: UIContext;
  contentNode: ComponentContent<Object>;
  content: ICustomDialogData;
  key: string;
  openListener: IHandleFunction[] = [];
  paramsUpdateListener: IHandleFunction[] = [];

  constructor(data: ICustomDialogData, key: string) {
    this.key = key;
    this.ctx = AppUtil.getUIContext();
    this.content = data;
    this.contentNode = new ComponentContent(this.ctx, data.wrappedBuilder, this.mergeParams())
  }

  get promptAction() {
    return this.ctx.getPromptAction();
  }

  onOpen(handle: Function, isOnce: boolean = false) {
    this.openListener.push({ handle, isOnce })
  }

  open(params?: ESObject): Promise<void> {
    if (params) {
      this.updateBuilderParams(params);
    }
    return new Promise((resolve, reject) => {
      this.promptAction.openCustomDialog(this.contentNode, this.content.options || {})
        .then(() => {
          if (this.openListener.length > 0) {
            const newHandles: IHandleFunction[] = [];
            this.openListener.forEach(item => {
              item.handle();
              if (!item.isOnce) {
                newHandles.push(item);
              }
            })
            this.openListener = newHandles;
          }
          Log.info('OpenCustomDialog complete.')
          resolve();
        }, reject)
        .catch((error: BusinessError) => {
          let message = (error as BusinessError).message;
          let code = (error as BusinessError).code;
          Log.info(`OpenCustomDialog args error code is ${code}, message is ${message}`);
          reject();
        })
    })
  }

  close() {
    if (this.contentNode !== null) {
      this.promptAction
        .closeCustomDialog(this.contentNode)
        .then(() => {
          Log.info('CloseCustomDialog complete.')
        })
        .catch((error: BusinessError) => {
          let message = (error as BusinessError).message;
          let code = (error as BusinessError).code;
          Log.info(`CloseCustomDialog args error code is ${code}, message is ${message}`);
        })
    }
  }

  updateOptions(options: promptAction.BaseDialogOptions) {
    if (this.contentNode !== null) {
      this.promptAction
        .updateCustomDialog(this.contentNode, options)
        .then(() => {
          this.content.options = options;
          Log.info('UpdateCustomDialog complete.')
        })
        .catch((error: BusinessError) => {
          let message = (error as BusinessError).message;
          let code = (error as BusinessError).code;
          Log.info(`UpdateCustomDialog args error code is ${code}, message is ${message}`);
        })
    }
    return this;
  }

  onParamsUpdate(handle: Function, isOnce: boolean = false) {
    this.paramsUpdateListener.push({ handle, isOnce })
  }

  updateBuilderParams(params: ESObject) {
    const mergeData = this.mergeParams(params);
    this.contentNode.update(mergeData);
    this.content.builderParams = params;
    const newHandles: IHandleFunction[] = [];
    this.paramsUpdateListener.forEach(item => {
      item.handle(params);
      if (!item.isOnce) {
        newHandles.push(item);
      }
    })
    this.paramsUpdateListener = newHandles;
    return this;
  }

  private mergeParams(params?: Object) {
    return ObjectUtil.assign(({} as ESObject), this.content.builderParams || ({} as ESObject),
      params || ({} as ESObject),
      { controller: this })
  }
}

export class CustomDialogManager {
  static dialogMap: Map<string, CustomDialogHandle> = new Map();

  static createHandle<T>(data: ICustomDialogData<T>, builderParams?: T, options?: promptAction.BaseDialogOptions,
    handleKey: string = "") {
    const mergeData: ICustomDialogData =
      ObjectUtil.assign(data, builderParams ? { builderParams } as ESObject : {} as ESObject,
        options ? { options } as ESObject : {} as ESObject) as ESObject;
    const key = `Custom-dialog-handle-key-${handleKey || Math.random()}`;
    const handle = new CustomDialogHandle(mergeData, key);
    CustomDialogManager.dialogMap.set(key, handle);
    return handle;
  }

  static closeAllDialog(handleKey: string = "", clear: boolean = false) {
    if (handleKey) {
      const handle = CustomDialogManager.dialogMap.get(handleKey);
      if (handle) {
        handle.close();
        clear && CustomDialogManager.dialogMap.delete(handleKey);
      }
    } else {
      CustomDialogManager.dialogMap.forEach((handle) => {
        handle.close();
      })
      clear && CustomDialogManager.dialogMap.clear();
    }
  }
}
```



## 路由方式兼容

```ts
import { router as pageRouter, uiObserver } from '@kit.ArkUI';
import { PATH_STACK } from './storage/storage.key';
import pageConfig from '../../resources/base/profile/main_pages.json';
import routeConfig from '../../resources/base/profile/route_map.json';
import { RouterClearMode } from '../constants/enum';
import { Log } from './log';
import { AppUtil } from '@pura/harmony-utils';
import { JSON } from '@kit.ArkTS';

const pages = pageConfig.src;

function logInfo(path: string, name?: string) {
  Log.info("---".repeat(20), "RouteTo");
  name && Log.info(`name: ${name}`, "RouteTo");
  Log.info(`path: ${path}`, "RouteTo");
}

function parsePathAndName(pathOrName: string) {
  const name = pathOrName.startsWith("pages/") ? pathOrName.split("/").pop() || "" : pathOrName;
  let path = pathOrName;
  if (!pathOrName.startsWith("pages/")) {
    const pageConfigItem = pageConfig.src.find(f => f.endsWith(pathOrName));
    if (pageConfigItem) {
      path = pageConfigItem
    } else {
      const routeConfigItem = routeConfig.routerMap.find(f => f.name === pathOrName)
      if (routeConfigItem) {
        path =
          routeConfigItem.pageSourceFile.slice(13, -4);
      }
    }
  }
  return [path, name]
}

type TCallbackEvent = (data?: ESObject) => void;

interface IBackEventData {
  isOnce: boolean;
  event: TCallbackEvent
}

interface IRouteLifeCycleEventData {
  isOnce: boolean;
  lifeCycle: uiObserver.RouterPageState | uiObserver.NavDestinationState;
  event: TCallbackEvent;
}

interface IPushRetHandle {
  /**
   * 返回事件监听，只执行一次
   * 返回到首页 pages/Index 时可能无法获取到返回参数
   * @param fn
   */
  onBackOnce: (fn: TCallbackEvent) => void;

  /**
   * 返回事件监听
   * 返回到首页 pages/Index 时可能无法获取到返回参数
   * @param fn
   */
  onBack: (fn: TCallbackEvent) => void;
}

interface ICurrentRouteStackInfo {
  path: string;
  params: ESObject;
}

class Router {
  isInit: boolean = false;
  initEvent: Function[] = [];
  backListenerMap: Map<string, IBackEventData[]> = new Map();
  routeActiveListenerMap: Map<string, IRouteLifeCycleEventData[]> = new Map();
  private currentStackInfo: ICurrentRouteStackInfo = {
    path: '',
    params: undefined
  };

  /* 获取NavPushStack 实例 */
  get stackRouter() {
    return AppStorage.get(PATH_STACK) as NavPathStack;
  }

  /* 现在是否是在 main_pages.json 中注册的页面中 */
  get isInPage() {
    const state = pageRouter.getState();
    return state && `${state.path}${state.name}` !== "pages/Index" && pages.includes(`${state.path}${state.name}`);
  }

  /* 注册事件，会在router初始化完成的时候执行 */
  onRouterInit(event: Function) {
    this.initEvent.push(event);
  }

  /* 初始化 */
  routerInit(navStack: NavPathStack) {
    AppStorage.setOrCreate(PATH_STACK, navStack);
    this.initPageStackInterceptor();
    this.isInit = true;
    setTimeout(() => {
      this.initEvent.forEach(item => {
        item();
      })
    }, 16)
  }

  /**
   * 获取当前页面的路径
   * @returns
   */
  getCurrentPagePath() {
    if (this.isInPage) {
      const state = pageRouter.getState();
      const pagePath = `${state.path}${state.name}`
      return pagePath;
    } else {
      const stackPath = this.currentStackInfo.path.replace("src/main/ets/", "");
      return stackPath;
    }
  }

  /**
   * 运行路由返回监听事件
   */
  runBackEvent(pagePath: string, params?: ESObject) {
    const listeners = this.backListenerMap.get(pagePath);
    if (!listeners || listeners.length === 0) {
      return;
    }
    const newListeners: IBackEventData[] = [];
    for (let listener of listeners) {
      listener.event(params);
      if (!listener.isOnce) {
        newListeners.push(listener);
      }
    }
    this.backListenerMap.set(pagePath, newListeners);
  }

  /*
   * 向路由栈中添加一个页面
   * @param pathOrName 路径或者路由名字
   * @param params 参数
   * */
  push(pathOrName: string, params?: ESObject): IPushRetHandle {
    const pathAndName = parsePathAndName(pathOrName);
    const path = pathAndName[0];
    const name = pathAndName[1];
    const pagePath = this.getCurrentPagePath();
    if (pages.includes(path)) {
      logInfo(path, name);
      pageRouter.pushUrl({ url: path, params }, pageRouter.RouterMode.Standard, (err) => {
        if (err) {
          Log.info(`pushUrl failed, code is ${err.code}, message is ${err.message}`);
          return;
        }
        Log.info('pushUrl success');
      });
    } else {
      this.stackRouter.pushPathByName(name, params);
    }
    return {
      onBackOnce: (fn) => {
        const events = this.backListenerMap.get(pagePath) ?? [];
        const data: IBackEventData = { isOnce: true, event: fn };
        this.backListenerMap.set(pagePath, [...events, data]);
      },
      onBack: (fn) => {
        const events = this.backListenerMap.get(pagePath) ?? [];
        const data: IBackEventData = { isOnce: false, event: fn };
        this.backListenerMap.set(pagePath, [...events, data]);
      },
    }
  }

  /*
   * 向路由栈中替换当前页面
   * @param pathOrName 路径或者路由名字
   * @param params 参数
   * */
  replace(pathOrName: string, params?: ESObject) {
    const pathAndName = parsePathAndName(pathOrName);
    const path = pathAndName[0];
    const name = pathAndName[1];
    if (pages.includes(path)) {
      logInfo(path, name);
      pageRouter.replaceUrl({ url: path, params }, pageRouter.RouterMode.Standard);
    } else {
      this.stackRouter.replacePathByName(name, params);
    }
  }

  /*
   * 清除路由栈
   * @param mode 清除模式，
   *  Page 只清除 main_pages.json 中的页面
   *  Stack 只清除 NavPushStack 中的页面
   *  Both 两个都清除
   * */
  clear(mode: RouterClearMode) {
    let clearFn = () => {
    };
    const clearPage = () => {
      pageRouter.clear();
    }
    const clearStack = () => {
      this.stackRouter.clear();
    }
    switch (mode) {
      case RouterClearMode.Page:
        clearFn = clearPage;
        break;
      case RouterClearMode.Stack:
        clearFn = clearStack;
        break;
      case RouterClearMode.Both:
        clearFn = () => {
          clearPage();
          clearStack();
        };
        break;
    }
    clearFn();
  }

  /*
   * 返回指定页面
   * @param pathOrNameOrDelta 不传表示返回上一页，可以是路径、名字、返回的层数
   * */
  backTo(pathOrNameOrDelta?: string | number, params?: ESObject) {
    if (typeof pathOrNameOrDelta === "undefined") {
      if (this.isInPage) {
        const length = Number(pageRouter.getLength());
        pageRouter.back(length - 1, params);
        setTimeout(() => {
          let pageState = pageRouter.getState();
          const pagePath = this.getCurrentPagePath();
          this.runBackEvent(pagePath, params);
          logInfo(pageState.path, pageState.name);
        })
      } else {
        this.currentStackInfo.params = params;
        this.stackRouter.pop(params);
      }
    } else if (typeof pathOrNameOrDelta === "string") {
      const pathAndName = parsePathAndName(pathOrNameOrDelta);
      const path = pathAndName[0];
      if (this.isInPage) {
        const length = Number(pageRouter.getLength());
        if (length) {
          let lastIndex = length;
          let isFound = false;
          while (lastIndex >= 0) {
            let pageState = pageRouter.getStateByIndex(lastIndex);
            if (pageState && `${pageState.path}${pageState.name}` === path) {
              isFound = true;
              logInfo(path, pageState.name);
              break;
            }
            lastIndex--;
          }
          if (isFound) {
            pageRouter.back(length - lastIndex, params)
            this.runBackEvent(path, params);
          }
        }
      } else {
        this.currentStackInfo.params = params;
        const hasStack = this.stackRouter.popToName(pathOrNameOrDelta, params);
        if (hasStack === -1) {
          this.clear(RouterClearMode.Stack);
          this.push(pathOrNameOrDelta, params);
        }
      }
    } else if (typeof pathOrNameOrDelta === "number") {
      if (this.isInPage) {
        pageRouter.back(pathOrNameOrDelta, params)
        setTimeout(() => {
          let pageState = pageRouter.getState();
          const pagePath = this.getCurrentPagePath();
          this.runBackEvent(pagePath, params);
          logInfo(pageState.path, pageState.name);
        })
      } else {
        this.currentStackInfo.params = params;
        const totalSize = this.stackRouter.size();
        this.stackRouter.popToIndex(totalSize - pathOrNameOrDelta - 1, params);
      }
    }
  }

  /*
   * 获取指定页面路由参数
   * @param pathOrName 不传表示获取当前页面的路由参数
   * */
  getParams(pathOrName?: string, defaultValue: ESObject = {}): ESObject | undefined {
    if (!pathOrName) {
      if (this.isInPage) {
        return pageRouter.getParams();
      } else {
        return this.stackRouter.getParamByIndex(this.stackRouter.size() - 1) as Object;
      }
    } else {
      const pathAndName = parsePathAndName(pathOrName);
      const path = pathAndName[0];
      const name = pathAndName[1];
      if (this.isInPage) {
        const length = Number(pageRouter.getLength());
        if (length) {
          let index = 0;
          while (index <= length) {
            let pageState = pageRouter.getStateByIndex(index);
            if (pageState && `${pageState.path}${pageState.name}` === path) {
              return pageState.params;
            }
            index++;
          }
        }
        return defaultValue;
      } else {
        return this.stackRouter.getParamByName(name).pop() as Object;
      }
    }
  }

  /*获取NavPushStack栈的大小*/
  getStackSize() {
    return this.stackRouter.size();
  }

  /*是否有路由历史*/
  hasHistory() {
    if (this.isInPage) {
      return Number(pageRouter.getLength()) > 1;
    } else {
      return this.stackRouter.size() >= 1;
    }
  }

  /**
   * 初始化NavPushStack的路由拦截器
   */
  private initPageStackInterceptor() {
    this.stackRouter.setInterception({
      willShow: (from: NavDestinationContext | "navBar", to: NavDestinationContext | "navBar",
        operation: NavigationOperation, animated: boolean) => {
        if (typeof to === "string") {
          const indexInfo = parsePathAndName("Index");
          logInfo(indexInfo[0], indexInfo[1]);
          if (operation === NavigationOperation.POP) {
            this.runBackEvent(indexInfo[0], this.currentStackInfo.params);
          }
          this.currentStackInfo.path = indexInfo[0];
          this.runRouteActiveEvent(indexInfo[1], uiObserver.RouterPageState.ABOUT_TO_APPEAR)
          return;
        }
        if (to.getConfigInRouteMap) {
          const info = to.getConfigInRouteMap();
          if (operation === NavigationOperation.POP) {
            const stackPath = info?.pageSourceFile.replace("src/main/ets/", "")
            this.runBackEvent(stackPath, this.currentStackInfo.params);
          }
          this.currentStackInfo.path = info?.pageSourceFile;
          this.runRouteActiveEvent(info?.pageSourceFile, uiObserver.RouterPageState.ABOUT_TO_APPEAR)
          logInfo(info?.pageSourceFile, info?.name);
        }
      }
    })
  }

  /**
   * 注册路由激活事件
   * @param pagePath
   * @param fn
   */
  onRouteActive(pagePath: string, fn: TCallbackEvent,
    lifeCycle: uiObserver.RouterPageState = uiObserver.RouterPageState.ABOUT_TO_APPEAR) {
    const events = this.routeActiveListenerMap.get(pagePath) ?? [];
    const data: IRouteLifeCycleEventData = {
      isOnce: true,
      event: fn,
      lifeCycle,
    };
    this.routeActiveListenerMap.set(pagePath, [...events, data]);
  }

  /**
   * 移除路由激活事件监听
   * @param pagePath
   * @param fn
   */
  offRouteActive(pagePath?: string, fn?: TCallbackEvent) {
    if (!pagePath) {
      this.routeActiveListenerMap = new Map();
    } else if (pagePath && !fn) {
      this.routeActiveListenerMap.set(pagePath, []);
    } else if (pagePath && fn) {
      const events = this.routeActiveListenerMap.get(pagePath) ?? [];
      const filterList = events.filter(f => f.event !== fn);
      this.routeActiveListenerMap.set(pagePath, filterList);
    }
  }

  /**
   * 运行路由激活事件
   */
  runRouteActiveEvent(pathOrName: string | ResourceStr,
    state: uiObserver.RouterPageState | uiObserver.NavDestinationState) {
    const pathAndName = parsePathAndName(pathOrName as string);
    const path = pathAndName[0];
    const name = pathAndName[1];
    let listeners = this.routeActiveListenerMap.get(name) ?? this.routeActiveListenerMap.get(path);
    let key = name;
    if (!listeners) {
      listeners = this.routeActiveListenerMap.get(path);
      key = path;
    }
    if (!listeners || listeners.length === 0) {
      return;
    }
    const newListeners: IRouteLifeCycleEventData[] = [];
    for (let listener of listeners) {
      if (listener.lifeCycle === state) {
        listener.event();
        if (!listener.isOnce) {
          newListeners.push(listener);
        }
      }
    }
    this.backListenerMap.set(key, newListeners);
  }

  initObserverEvent() {
    const context = AppUtil.getContext();
    uiObserver.on('navDestinationUpdate', (info) => {
      this.runRouteActiveEvent(info.name, info.state);
    });
    uiObserver.on('routerPageUpdate', context, (info: uiObserver.RouterPageInfo) => {
      this.runRouteActiveEvent(info.name, info.state);
    })
    uiObserver.on('tabContentUpdate', (info: uiObserver.TabContentInfo) => {
      Log.info(['tabContentUpdate', JSON.stringify(info)]);
    });
  }
}

export const router = new Router();
```

