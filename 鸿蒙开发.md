## Artts

Artts其实就是TypeScript的一个超集，但是又移除了一些方法和特性，比如不支持delete，for .. in，不支持 any （any类型可以用 ESObject 代替）等。[从TypeScript到ArkTS的适配规则](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/typescript-to-arkts-migration-guide)

## ForEach 的key问题

在使用`ForEach`进行循环渲染的时候要注意 key 默认情况下key是通过函数`(item: Object, index: number) => { return index + '__' + JSON.stringify(item); }`生成的， 如果相同的key就只会渲染一遍，比如`['one','two','two','three']`在 keyGenerator 函数为`item => item`是就只会渲染`one','two','three'`。需要制定不同的key，获取不写 keyGenerator 函数才会全部渲染

```tsx
@State simpleList: Array<string> = ['one', 'two', 'two', 'three'];

ForEach(this.simpleList, (item: string) => {
  ChildItem({ item: item })
},(_,idx:number) => idx);

```



## Row/Column/Grid 高度错误的问题

在使用`Grid`和`Row/Column`多层嵌套并且没有设置高度的时候可能会导致高度占满容器高度，比如

```tsx
Column() {
  Column() {
    Column() {
      Row() {
        Text("title")
      }

      Grid() {
        GridItem() {
          Column() {
            Text("test1")
          }
        }

        GridItem() {
          Column() {
            Text("test2")
          }
        }
      }.columnsTemplate('1fr 1fr')
    }
  }

  Text("footer")
}
```

`grid`的高度就会显示异常，可以通过设置高度的方式解决，也可以通过在外层用`Scroll/List`进行包裹来解决，还可以用`GridRow/GridCol`代替`Grid/GridItem`解决

```tsx
Column() {
  Scroll() {
    Column() {
      Row() {
        Text("title")
      }

      Grid() {
        GridItem() {
          Column() {
            Text("test1")
          }
        }

        GridItem() {
          Column() {
            Text("test2")
          }
        }
      }.columnsTemplate('1fr 1fr')
    }
  }

  Text("footer")
}
```

```tsx
Column() {
  Column() {
    Column() {
      Row() {
        Text("title")
      }
      GridRow({
        columns: {xs: 2, sm: 2, md: 2, lg: 2, xl: 2, xxl: 2
        },
      }) {
        GridCol() {
          Text("GridCol1")
        }

        GridCol() {
          Text("GridCol2")
        }
      }
    }
  }

  Text("footer")
}
```



## 状态管理

### V1

鸿蒙的状态管理类似于`Vue`，同样是使用`Proxy`对数据进行劫持，以及对依赖此数据组件进行依赖搜集，当绑定的数据更新时更新组件。但是需要注意在`状态管理V1`的时候使用`@State`修饰的数据，如果是对象就只能对第一层的数据进行监听，深层次的数据更新并不会触发组件更新，如果需要深层次的数据也触发组件更新的话就需要为这个数据创建一个类并使用`@Observed`装饰，并且**这个类同样只有第一层数据的数据变化的时候才会触发组件更新，深层的数据还是需要使用`@Observed`装饰，并且需要注意深层的这个数据必须要传递给子组件，子组件通过`@ObjectLink`接收使用才会响应更新**

```tsx
@Observed
class Data2 {
  count: number = 0;
}

interface Data1 {
  count: number;
  child: Data2
}

@Component
struct Children {
  @ObjectLink data: Data2

  build() {
    Text("Children data2.count:" + this.data.count).onClick(() => {
      this.data.count += 1;// 会更新但是父组件不会更新
    })
  }
}

@Component
export struct TestExample {
  @State data: Data1 = {
    count: 0,
    child: new Data2
  };

  build() {
    NavDestination() {
      Column({ space: 10 }) {
        Text("data1.count:" + this.data.count).onClick(() => {
          this.data.count += 1;//会更新
        })
        Text("data1.child.count:" + this.data.child.count).onClick(() => {
          this.data.child.count += 1;//不会更新，Children会更新
        })

        Children({
          data: this.data.child
        })
      }
    }.title("StateV1")
  }
}
```

可以发现在使用`@Observed/@ObjectLink`时如果要做响应式的深层数据的话，要么就需要使用为每一个子对象数据创建一个类和组件，要么就需要将这些深层的数据提取出来扁平化处理用多个`@State`装饰的变量处理，或者将子对象数据扁平化之后塞到一个对象中形成新的对象（但是这样处理后也就不需要使用`@Observed/@ObjectLink`了）。

**@Prop装饰变量时会进行深拷贝，在拷贝的过程中除了基本类型、Map、Set、Date、Array外，都会丢失类型**

### V2

**@Local的观测能力仅限于被装饰的变量本身。当装饰简单类型时，能够观测到对变量的赋值；当装饰对象类型时，仅能观测到对对象整体的赋值；当装饰数组类型时，能观测到数组整体以及数组元素项的变化；当装饰Array、Set、Map、Date等内嵌类型时，可以观测到通过API调用带来的变化**

也就说对于对象来说只能通过重新赋值整个对象才能触发更新。和React的redux思想相似，在React中更新Store中对象中某个属性的数据状态的时候可以使用对象扩展来快速浅拷贝，但是在artts中时不支持对象扩展运算的，这就变得非常麻烦。要实现对象的响应式更新就需要使用`@ObservedV2/@Trace`来定义对象中的哪个属性时需要成为响应式数据，如果需要成为响应式数据的属性很多那就更麻烦了。

### V1和V2融合使用

我们其实可以将`V1`版本对对象的浅层数据都转化响应式数据的特性和`V2`的`@ObservedV2/@Trace`可以自定义响应式数据而不用在子组件中使用的特性结合起来就可以得到一个类似`Vue`的状态管理系统。

需要注意`V2`的`@ObservedV2`装饰的类不能直接使用在`V1`的装饰器中，但是可以使用在对象的内部

```tsx
@ObservedV2
class Data{
	@Trace
  name:string = "";
}
@State data:DataV2 = new Data();// 这样是不行的

interface WrapData = {
  data:Data
}
@State data:WrapData = {
  data:new Data
};// 这样是可以的
```

在项目中我们可以创建一个专门将普通数据转化成响应式数据的类

```ts
@ObservedV2
class Ref<T>{
	@Trace
  value:T;
  constructor(val:T){
    this.value = val;
  }
}
```

其实这个就和`Vue3`中对普通类型数据使用`ref`处理是一样的思想，在使用的时候需要保持数据的引用不变

```tsx
@ObservedV2
class Ref<T> {
  @Trace
  value: T;

  constructor(val: T) {
    this.value = val;
  }
}

interface Data {
  count: number
  child: Child
}

interface Child {
  count: number
  count2: Ref<number>;
}

@Component
export struct TestExample {
  @State data: Data = {
    count: 0,
    child: {
      count: 0,
      count2: new Ref<number>(0)
    }
  };

  build() {
    NavDestination() {
      Text("data.count:" + this.data.count).onClick(() => {
        this.data.count += 1;// 会更新
      })
      Text("data.child.count:" + this.data.child.count).onClick(() => {
        this.data.child.count += 1;// 不会更新
      })
      Text("data.child.count2:" + this.data.child.count2.value).onClick(() => {
        this.data.child.count2.value += 1;// 会更新
      })
    }.title("xxxx")

  }
}
```

在使用`Ref`的时候还有几个问题需要特别注意：

1. 在使用`JSON.stringify`的时候会使`Ref`转换成普通对象数据并且丢失响应式特性。
2. `@Prop`接收的数据是进行深拷贝过的，即使对象能正常使用但是在子组件修改数据的也是不会响应同步到父组件
3. `@Link`是**无法接收非`V1`状态装饰器装饰的数据**的（比如只能是上面data，data中的数据也是不行的），也就无法使用这个特性实现双向数据同步

所以在开发的时候，在使用 `Ref`时尽量不要用`JSON.stringify`进行操作（比如复制）要确保 `Ref` 对象不变，仅修改`Ref.value`。尽量使用接口类的方式进行状态的管理，比如我们要接收用户的信息之后，需要对用户的名称`name`，存款`amount`修改，那么我们可以先创建一个接口`IUserInfo`，然后再实现这个接口`UserInfo`

```tsx
interface IUserInfo {
  name: string;
  age: number;
  deposit: IDeposit
}

interface IDeposit {
  amount: number;
  unit: string;
  bank: string;
}

class UserInfo implements IUserInfo {
  private _name: Ref<string> = new Ref("");
  age: number = 0;
  deposit: Deposit = new Deposit();

  constructor(data?: IUserInfo) {
    if (data) {
      ObjectUtil.assign(this, data);
      this.deposit = new Deposit(data.deposit);
    }
  }

  get name() {
    return this._name.value;
  }

  set name(val: string) {
    this._name.value = val;
  }

  valueOf(): IUserInfo {
    return {
      name: this.name,
      age: this.age,
      deposit: this.deposit.valueOf(),
    };
  }
}

class Deposit implements IDeposit {
  private _amount: Ref<number> = new Ref(0);
  private _bank: Ref<string> = new Ref("");
  unit: string = "CNY";

  constructor(data?: IDeposit) {
    if (data) {
      ObjectUtil.assign(this, data);
    }
  }

  get amount() {
    return this._amount.value;
  }

  set amount(val: number) {
    this._amount.value = val;
  }

  get bank() {
    return this._bank.value;
  }

  set bank(val: string) {
    this._bank.value = val;
  }

  valueOf(): IDeposit {
    return {
      unit: this.unit,
      amount: this.amount,
      bank: this.bank,
    };
  }
}
```

这样包装过后就不用担心`Ref`被不确定的修改，同时使用`valueOf` 方法就可以提取出纯数据对象之后使用`JSON.Stringify`对纯数据对象操作也就可以了。那么在组件中这些数据的使用效果

```tsx
const getUserInfo: () => Promise<IUserInfo> = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const userInfo: IUserInfo = {
        name: 'jack',
        age: 18,
        deposit: {
          amount: 10000,
          unit: "CNY",
          bank: "CCIT"
        }
      }
      resolve(userInfo);
    }, 300)
  })
}

@Component
export struct DepositInfo {
  @Prop deposit: Deposit;

  build() {
    Column({ space: 10 }) {
      Text(`deposit amount: ${this.deposit.unit} ${this.deposit.amount}`);
      Text(`deposit bank: ${this.deposit.bank}`);
      Text("change bank").backgroundColor("red").onClick(() => {
        this.deposit.bank += 1; // 会更新，但父组件不会更新
      })
      Text("change amount").backgroundColor("red").onClick(() => {
        this.deposit.amount += 1; // 会更新，但父组件不会更新
      })
    }.backgroundColor(Color.Blue);
  }
}

@Component
export struct TestExample {
  @State userInfo: UserInfo = new UserInfo();

  async aboutToAppear() {
    const userData = await getUserInfo();
    this.userInfo = new UserInfo(userData);
  }

  build() {
    NavDestination() {
      Column({ space: 10 }) {
        Text("user name:" + this.userInfo.name)
        Text("user deposit bank:" + this.userInfo.deposit.bank)
        Text("change name").backgroundColor("red").onClick(() => {
          this.userInfo.name += "1"; // 会更新
        })
        Text("change deposit bank").backgroundColor("red").onClick(() => {
          this.userInfo.deposit.bank += "1"; // 会更新，但子组件不会更新
        })
        Text("change deposit").backgroundColor("red").onClick(() => {
          this.userInfo.deposit.amount += 1; // 不会更新
        })

        Divider()

        DepositInfo({
          deposit: this.userInfo.deposit
        })
      }
    }.title("xxxx")
  }
}
```

会发现在父组件中，即使是深层的数据修改也会更新页面，但是在父组件中更新深层的数据对象并不能触发依赖这个数据的子组件更新，这是因为`@Prop`会进行深拷贝，将原来数据和组件的依赖关系清除。那么如果要使得深层的数据更新子组件也更新（`@Link`的效果）应该怎么修改？答案是不使用`@Prop`直接传数据（但是要确保初始化时就绑定同一对象，因为不使用`@Prop`在对象更新时并不能触发子组件更新去同步对象数据）

```tsx
class SourceSync {
  setData(data?: ESObject, keyHandle?: (key: string, value: ESObject) => boolean) {
    this.syncData(data, keyHandle);
  }

  syncData(data?: ESObject, keyHandle?: (key: string, value: ESObject) => boolean) {
    if (data) {
      const target = this as Record<string, ESObject>;
      const source = data as Record<string, ESObject>;
      const keys = Object.keys(source);
      for (let key of keys) {
        if (keyHandle && keyHandle(key, source[key])) {
          continue;
        }
        target[key] = source[key];
      }
    }
  }

  valueOf(): Record<string, ESObject> {
    const target = this as Record<string, ESObject>;
    const objKeys = Object.keys(target);
    const record: Record<string, ESObject> = {};
    for (let key of objKeys) {
      if (key === "propChangeListeners") {
        continue;
      }
      if (key.startsWith("_")) {
        const tempKey = key.slice(1);
        record[tempKey] = target[tempKey];
        continue;
      }
      if (target[key] instanceof SourceSync) {
        record[key] = target[key].valueOf()
        continue;
      }
      record[key] = target[key];
    }
    return record;
  }

  private propChangeListeners: Array<(key: string, value: ESObject) => void> = [];

  onPropChange(fn: (key?: string, value?: ESObject) => void) {
    this.propChangeListeners.push(fn);
  }

  offPropChange(fn: (key?: string, value?: ESObject) => void) {
    this.propChangeListeners = this.propChangeListeners.filter(ev => ev !== fn)
  }

  emitPropListeners(key: string, value: ESObject) {
    this.propChangeListeners.forEach(fn => {
      fn(key, value);
    })
  }
}

class UserInfo extends SourceSync implements IUserInfo {
  private _name: Ref<string> = new Ref("");
  age: number = 0;
  deposit: Deposit = new Deposit();

  constructor(data?: IUserInfo) {
    super();
    this.setData(data);
  }

  setData(data?: ESObject): void {
    this.syncData(data, (key, value: ESObject) => {
      if (key === "deposit") {
        this.deposit.setData(value);
        return true;
      }
      return false;
    })
  }

  get name() {
    return this._name.value;
  }

  set name(val: string) {
    this._name.value = val;
  }
}

class Deposit extends SourceSync implements IDeposit {
  private _amount: Ref<number> = new Ref(0);
  private _bank: Ref<string> = new Ref("");
  unit: string = "CNY";

  constructor(data?: IDeposit) {
    super();
    this.setData(data);
  }

  get amount() {
    return this._amount.value;
  }

  set amount(val: number) {
    this._amount.value = val;
  }

  get bank() {
    return this._bank.value;
  }

  set bank(val: string) {
    this._bank.value = val;
  }
}
```

```tsx
@Component
export struct DepositInfo {
  deposit?: Deposit;
  build() {
    Column({ space: 10 }) {
      Text(`deposit amount: ${this.deposit?.unit} ${this.deposit?.amount}`);
      Text(`deposit bank: ${this.deposit?.bank}`);
      Text("change bank").backgroundColor("red").onClick(() => {
        this.deposit && (this.deposit.bank += 1); // 会更新，父组件也会更新
      })
      Text("change amount").backgroundColor("red").onClick(() => {
        this.deposit && (this.deposit.amount += 1); // 会更新，父组件也会更新
      })
    }.backgroundColor(Color.Blue);
  }
}

@Component
export struct TestExample {
  @State userInfo: UserInfo = new UserInfo();
  async aboutToAppear() {
    const userData = await getUserInfo();
    // this.userInfo = new UserInfo(userData);
    this.userInfo.setData(userData);
  }
}
```







## cancas尺寸坑导出类型

## 自定义弹窗的数据传递

## 路由方式兼容

## 深层数据不支持更新解决方案

